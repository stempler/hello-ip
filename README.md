# hello-ip

A simple web application for authenticating users and maintaining an IP whitelist with configurable expiration and maximum entry limits.

## Features

- Web-based authentication interface
- Persistent IP whitelist storage with expiration
- Internal endpoint for retrieving whitelist as text file
- Docker containerization with environment variable configuration
- Support for multiple credentials

## Quick Start

### Using Docker

1. Build the Docker image:
```bash
docker build -t hello-ip .
```

2. Generate password hashes using the helper script:
```bash
python hash_password.py secret123 admin
python hash_password.py password456 user1
```

3. Run the container with hashed credentials:
```bash
docker run -d \
  -p 8080:8080 \
  -p 8081:8081 \
  -v whitelist-data:/data \
  -e CREDENTIALS='{"admin": "pbkdf2:sha256:...", "user1": "pbkdf2:sha256:..."}' \
  -e BASE_PATH="/" \
  -e ENTRY_VALIDITY_HOURS=24 \
  -e MAX_ENTRIES=1000 \
  --name ip-whitelist \
  ip-whitelist-app
```

4. Access the web interface at `http://localhost:8080`
5. Retrieve the whitelist at `http://localhost:8081/whitelist.txt`

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `BASE_PATH` | Base URL path for the application | `/` |
| `MAIN_PORT` | Port for main web interface | `8080` |
| `INTERNAL_PORT` | Port for whitelist endpoint | `8081` |
| `ENTRY_VALIDITY_HOURS` | Hours until whitelist entry expires | `24` |
| `MAX_ENTRIES` | Maximum number of whitelist entries | `1000` |
| `DATABASE_PATH` | SQLite database file path | `/data/whitelist.db` |
| `CREDENTIALS` | JSON string of credential IDs to password hashes | `{}` |
| `GUNICORN_WORKERS` | Number of gunicorn worker processes for main app | `4` |
| `GUNICORN_THREADS` | Number of threads per worker | `2` |

### Credentials Format

The `CREDENTIALS` environment variable should be a JSON object mapping credential IDs to **password hashes** (not plain text passwords). Use the `hash_password.py` helper script to generate hashes.

**Important:** Never store plain text passwords in the `CREDENTIALS` environment variable. Always use password hashes generated by the helper script.

#### Generating Password Hashes

Use the `hash_password.py` script to generate password hashes:

```bash
# Generate a hash for a single password
python hash_password.py mypassword

# Generate a JSON object ready for CREDENTIALS env var
python hash_password.py mypassword admin
# Output: {"admin": "pbkdf2:sha256:600000$..."}

# Combine multiple credentials
python hash_password.py secret123 admin
python hash_password.py password456 user1
# Then combine the outputs into a single JSON object:
# {"admin": "pbkdf2:sha256:...", "user1": "pbkdf2:sha256:..."}
```

Example `CREDENTIALS` environment variable:
```json
{"admin": "pbkdf2:sha256:600000$...", "user1": "pbkdf2:sha256:600000$..."}
```

## API Endpoints

### Main Application (Port 8080)

- `GET /` - Authentication web interface
- `POST /auth` - Authenticate and add IP to whitelist
  - Request body: `{"credential_id": "admin", "password": "secret123"}`
  - Returns 200 on success, 403 on authentication failure
- `GET /health` - Health check endpoint

### Internal Endpoint (Port 8081)

- `GET /whitelist.txt` - Returns text file with valid IP addresses (one per line)
- `GET /whitelist.json` - Returns JSON with all whitelist entry information
  - Query parameter `?all=true` - Include expired entries (default: only valid entries)
  - Response format:
    ```json
    {
      "count": 5,
      "valid_only": true,
      "entries": [
        {
          "ip": "192.168.1.1",
          "credential_id": "admin",
          "auth_time": "2024-01-15T10:30:00",
          "expires_at": "2024-01-16T10:30:00",
          "is_valid": true,
          "remaining_seconds": 86400
        }
      ]
    }
    ```

## Development

### Local Development with mise-en-place

This project uses [mise-en-place](https://mise.jdx.dev/) (formerly rtx) for tool version management with automatic virtualenv activation.

1. Install mise-en-place if you haven't already:
```bash
# Follow installation instructions at https://mise.jdx.dev/getting-started.html
```

2. Install the required tools (this will install Python 3.11):
```bash
mise install
```

3. Activate the mise environment (add to your shell config for automatic activation):
```bash
eval "$(mise activate)"
```

4. Navigate to the project directory - mise will automatically:
   - Use Python 3.11
   - Create the `.venv` virtual environment if it doesn't exist
   - Activate the virtual environment automatically

5. Install dependencies:
```bash
pip install --upgrade pip
pip install -r requirements.txt
```

6. Generate password hashes and set environment variables:
```bash
# Generate password hash
python hash_password.py secret123 admin
# Output: {"admin": "pbkdf2:sha256:..."}

# Set environment variables (use the hash from above)
export CREDENTIALS='{"admin": "pbkdf2:sha256:..."}'
export DATABASE_PATH="./whitelist.db"
```

7. Run the application:
```bash
python app.py
```

**Note:** The `.mise.toml` file configures Python 3.11 and uses [automatic virtualenv activation](https://mise.jdx.dev/lang/python.html#automatic-virtualenv-activation). When you're in the project directory with mise activated, the virtual environment will be automatically created (if needed) and activated. No manual `python -m venv` or `source .venv/bin/activate` needed!

### Local Development (without mise-en-place)

If you prefer not to use mise-en-place, ensure you have Python 3.11+ installed and follow steps 4-7 above.

## Production Deployment

The Docker image uses **gunicorn** as a production WSGI server instead of Flask's development server. The application runs with:

- **Main app** (port 8080): Production WSGI server with configurable workers
- **Internal app** (port 8081): Lightweight server for internal whitelist endpoint

You can configure gunicorn workers and threads via environment variables:
```bash
-e GUNICORN_WORKERS=4 \
-e GUNICORN_THREADS=2
```

For local development, you can still use `python app.py` which uses Flask's development server (with the warning).

## Security Considerations

- Passwords are hashed using Werkzeug's secure password hashing
- Credentials are stored only in environment variables (not in the database)
- SQL injection prevention via parameterized queries
- Separate ports for internal vs public access
- Input validation for IP addresses
- Non-root user in Docker container
- Production WSGI server (gunicorn) in Docker image

## Database Schema

The application uses SQLite with one table:

- `whitelist_entries`: Stores IP addresses, credential IDs, authentication time, and expiration time

**Note:** Credentials are not stored in the database. They are configured via the `CREDENTIALS` environment variable and verified at runtime.

## License

MIT

